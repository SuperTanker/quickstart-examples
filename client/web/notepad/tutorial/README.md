# Notepad application tutorial

In this tutorial we will demonstrate how to use the Tanker SDK inside an existing React JavaScript application.

Knowledge about UI frameworks such as react is not required. However, the functions and methods  of the Tanker API are asynchronous, so to take out the most of this tutorial you should know about [async functions](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/async_function).

## Environment set up

Please check that [the server is started](../../../README.md) as this example application will rely on it.

## The application

### Description

The Web application is a simple notepad written in React.

Each user has access to exactly one note.

It implements the following features:

* Login
* Signing up
* Loading and saving the contents of the notes

Here is the user experience flow:

1. A user signs up and creates an account with an ID and password
2. He logs in
3. He is redirected to an edit form where he can type text, and save the contents by sending them to a remote server.

The server handles signing up of the users by hashing their passwords, and can also store the user notes. The server is also able to send [user tokens](https://www.tanker.io/docs/latest/guide/server/#user_token) to authenticated users.

### Run

To start the application, run in a new terminal:

```bash
yarn start:web:tutorial
```

The application should open in a new browser tab. If not, go to http://localhost:3000/ manually.

## Reproducing the tutorial

If you run the application now you will notice that the contents generated by the user are stored in plain text on the server. (You can see them in the `.json` files in the `./server/data/` directory.)

You will also notice that right after sign up, you are asked to save a mysterious "unlock key". We'll explain this later.

Right now, we are going to make sure the data is stored encrypted on the server, while still allowing users transparent access to their resources.

As explained above, the server already contains the required modifications.

Since the tanker SDK implements end-to-end encryption, most cryptographic operations will happen clients-side, so in this tutorial we will only have to change code in the `./client/web/tutorial/src/Session.js` file.

We've marked the places we are going to modify with these place holder comments:

```javascript
// [[
// FIXME
     <- code to change lies here
// ]]
```


## Step by step tutorial

### Handling a Tanker session

We use the `trustchainId` found in the config file to initialize a new Tanker instance:

```javascript
constructor() {
  ...
-  // FIXME: create a new tanker object with the trustchainId
+  const config = {
+      trustchainId;
+  }
+  this.tanker = new Tanker({ trustchainId });
}
```

Now we should handle the creation of a Tanker session.

We need to handle two cases here. Either the user just created an account, or he just logged in.

In both cases, the server should have sent a user token, and we can call `open()` right away.

Note that we use `await` because opening a Tanker session is not instantaneous, and we do not want to block the application while Tanker is opening.

```javascript
async create(userId: string, password: string): Promise<void> {
  // ...
  const userToken = await response.text

  // Open Tanker session with userId and userToken
- this.opened = true;
- await true;
+ return this.tanker.open(userId, userToken);
}

async login(userId: string, password: string): Promise<void> {
  // ...
- this.opened = true;
- await true
+ const userToken = await response.text();
+ await this.tanker.open(userId, userToken);
}
```

<!--FIXME: explain trustchain concept here -->

* `tanker.open()` will use the user token to:

    * Register the user in the trustchain if necessary
    * Register the device in the trustchain if necessary
    * Fetch access keys to all the resource

With this in place we can get rid of the `opened` attribute and fix the `isOpen` and `close` methods:

```javascript
constructor() {
  // ...
- this.opened = false;
}

isOpen(): bool {
  // Check Tanker status
- return this.opened;
+ return this.tanker.status === this.tanker.OPEN;
}

async close(): Promise<void> {
- this.opened = false;
+ await this.tanker.close();
}
```

The `.close()` method will be called when the user logs out. It's important to close the Tanker session too at this moment to make sure the encrypted data is safe at rest.

At this point, nothing has changed in the application, we just made sure we could open and close a Tanker section correctly.



* [Encrypting data](https://www.tanker.io/docs/latest/guide/encryption.md#encrypting)

To encrypt the data, we use `tanker.encrypt()`:

```javascript
async saveText(content: string): Promise<void> {
  // ...

  // use tanker to encrypt the text as binary data, then
  // encode the data and send it to the server

  - const encryptedData = content;
  - this.api.push(encryptedData);
  + const encryptedData = await this.tanker.encrypt(content);
  + this.api.push(toBase64(eData));
```

The `.encrypt` method takes a string as parameter and returns some binary data. Our server used to accept the contents of the notes as strings, that's why we use `toBase64` here.

* [Decrypting data](https://www.tanker.io/docs/latest/guide/encryption.md#decrypting)

To decrypt the data, we use the same steps, but in reverse order:

```javascript
async loadText(): Promise<string> {
  const data = await this.api.get)();
  // ...
  // use fromBase64 to get binary data from the
  // response of the server and use tanker to decrypt it.
- return data;
+ return this.tanker.decrypt(fromBase64(data));
```

Now the users can still load and save their notes, but now the contents are encrypted on the server. Feel free to take look at the `.json` files in the `./server/data/` directory to make sure.


### Device management

At this point, if you try to log in the same user in an other browser in private mode, or in any other device, you get an error message about a missing event handler.

That is because we did not take care of device management so far. Let's do that now.

* First, we connect the `waitingForValidation` event of the Tanker and emit the `newDevice` event when required.

``` javascript

async login(userId: string, password: string): Promise<void> {
+ this.tanker.on('waitingForValidation', () => this.emit('newDevice'));
}
```
That way, when the user needs to perform manual operations about its device, the UI will be notified.

(The 'newDevice' event is handled in the other React components of the application).

Then we implement the `getUnlockKey` and `addCurrentDevice` device methods in `./client/web/tutorial/src/Session.js`:

```javascript
async getUnlockKey(): Promise<string> {
  // ..

- return 'this is the unlock key';
- return this.tanker.generateAndRegisterUnlockKey();
}

async addCurrentDevice(unlockKey: string): Promise<void> {
- await true;
+ return this.tanker.unlockCurrentDevice(unlockKey);
}
```

So instead of display 'this in the unlock key' to the user, we actually ask Tanker to generate one.

Then, when the user needs the unlock a new device, the web application will end up calling `tanker.unlockCurrentDevice()`.

You can now check that device management is indeed working by following those steps:

* Sign up and log in a new user on one tab of your browser and save the unlock key.
* Then add and save some data.
* You should now be redirected to a page where you can enter the unlock key you saved in the previous step.
* Upon entering the unlock key, the second tab should contain the same content that was saved in the first tab.
* You can then change the contents on the second device, click save, go back to the first device, and load the new content.

## Conclusion

Congrats! You now have an example of a web application using end-to-end encryption.
